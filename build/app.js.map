{"version":3,"sources":["../src/app.ts"],"sourcesContent":["import 'express-async-errors';\nimport \"reflect-metadata\";\nimport express, { Application, NextFunction, Request, Response } from 'express';\n\nimport { UserController } from './controllers/users/user.controller.js';\nimport AuthController from './controllers/auth/auth.controller.js';\nimport { RoutingControllersOptions, getMetadataArgsStorage, useExpressServer } from \"routing-controllers\";\nimport { errorMiddleware, getAuthenticator } from \"@panenco/papi\";\nimport { validationMetadatasToSchemas } from 'class-validator-jsonschema';\nimport { getMetadataStorage } from 'class-validator';\nimport { routingControllersToSpec } from 'routing-controllers-openapi';\nimport swaggerUi from 'swagger-ui-express';\n\n\nexport class App {\n  host: Application;\n\n  constructor() {\n    // Init server\n    this.host = express();\n\n    // Allow json body\n    this.host.use(express.json());\n\n    // Example root endpoint\n    this.host.get(\"/\", (req: Request, res: Response) => {\n      res.send(\"Hello World!\");\n    });\n\n    // Custom before middleware\n    this.host.use((req: Request, res: Response, next: NextFunction) => {\n      console.log(req.method, req.url);\n      next();\n    });\n\n    this.initializeControllers([UserController, AuthController]);\n\n    // Custom after middleware (only used when res.send or json is not called in a previous middleware (no endpoint found))\n    this.host.use((req: Request, res: Response, next: NextFunction) => {\n      res.status(404).send(\"No Endpoint found\");\n    });\n\n    this.host.use(errorMiddleware);\n  }\n\n  private initializeControllers(controllers: Function[]) {\n    useExpressServer(this.host, { // Link the express host to routing-controllers\n      cors: {\n        origin: \"*\", // Allow all origins, any application on any url can call our api. This is why we also added the `cors` package.\n        exposedHeaders: [\"x-auth\"], // Allow the header `x-auth` to be exposed to the client. This is needed for the authentication to work later.\n      },\n      controllers, // Provide the controllers. Currently this won't work yet, first we need to convert the Route to a routing-controllers controller.\n      defaultErrorHandler: false, // Disable the default error handler. We will handle errors through papi later.\n      routePrefix: \"/api\", // Map all routes to the `/api` path.\n      authorizationChecker: getAuthenticator('jwtSecretFromConfigHere'), // Tell routing-controllers to use the papi authentication checker\n    });\n }\n\n private initializeSwagger() {\n  const schemas = validationMetadatasToSchemas({\n    classValidatorMetadataStorage: getMetadataStorage(),\n    refPointerPrefix: \"#/components/schemas/\",\n  });\n\n  const routingControllersOptions: RoutingControllersOptions = {\n    routePrefix: \"/api\",\n  };\n\n  const storage = getMetadataArgsStorage();\n  \n  const spec = routingControllersToSpec(storage, routingControllersOptions, {\n    components: {\n      schemas,\n      securitySchemes: {\n        JWT: {\n          in: \"header\",\n          name: \"x-auth\",\n          type: \"apiKey\",\n          bearerFormat: \"JWT\",\n          description: \"JWT Authorization header using the JWT scheme. Example: \\\"x-auth: {token}\\\"\",\n        },\n      },\n    },\n    security: [{JWT: []}],\n  });\n\n  this.host.use('/docs', swaggerUi.serve, swaggerUi.setup(spec));\n}\n\n  listen() {\n    this.host.listen(3000, () => {\n      console.info(`ðŸš€ http://localhost:3000`);\n      console.info(`=================================`);\n    });\n  }\n}\n"],"names":["express","UserController","AuthController","getMetadataArgsStorage","useExpressServer","errorMiddleware","getAuthenticator","validationMetadatasToSchemas","getMetadataStorage","routingControllersToSpec","swaggerUi","App","host","constructor","use","json","get","req","res","send","next","console","log","method","url","initializeControllers","status","controllers","cors","origin","exposedHeaders","defaultErrorHandler","routePrefix","authorizationChecker","initializeSwagger","schemas","classValidatorMetadataStorage","refPointerPrefix","routingControllersOptions","storage","spec","components","securitySchemes","JWT","in","name","type","bearerFormat","description","security","serve","setup","listen","info"],"mappings":"AAAA,OAAO,uBAAuB;AAC9B,OAAO,mBAAmB;AAC1B,OAAOA,aAA+D,UAAU;AAEhF,SAASC,cAAc,QAAQ,yCAAyC;AACxE,OAAOC,oBAAoB,wCAAwC;AACnE,SAAoCC,sBAAsB,EAAEC,gBAAgB,QAAQ,sBAAsB;AAC1G,SAASC,eAAe,EAAEC,gBAAgB,QAAQ,gBAAgB;AAClE,SAASC,4BAA4B,QAAQ,6BAA6B;AAC1E,SAASC,kBAAkB,QAAQ,kBAAkB;AACrD,SAASC,wBAAwB,QAAQ,8BAA8B;AACvE,OAAOC,eAAe,qBAAqB;AAG3C,OAAO,MAAMC;IACXC,KAAkB;IAElBC,aAAc;QACZ,cAAc;QACd,IAAI,CAACD,IAAI,GAAGZ;QAEZ,kBAAkB;QAClB,IAAI,CAACY,IAAI,CAACE,GAAG,CAACd,QAAQe,IAAI;QAE1B,wBAAwB;QACxB,IAAI,CAACH,IAAI,CAACI,GAAG,CAAC,KAAK,CAACC,KAAcC;YAChCA,IAAIC,IAAI,CAAC;QACX;QAEA,2BAA2B;QAC3B,IAAI,CAACP,IAAI,CAACE,GAAG,CAAC,CAACG,KAAcC,KAAeE;YAC1CC,QAAQC,GAAG,CAACL,IAAIM,MAAM,EAAEN,IAAIO,GAAG;YAC/BJ;QACF;QAEA,IAAI,CAACK,qBAAqB,CAAC;YAACxB;YAAgBC;SAAe;QAE3D,uHAAuH;QACvH,IAAI,CAACU,IAAI,CAACE,GAAG,CAAC,CAACG,KAAcC,KAAeE;YAC1CF,IAAIQ,MAAM,CAAC,KAAKP,IAAI,CAAC;QACvB;QAEA,IAAI,CAACP,IAAI,CAACE,GAAG,CAACT;IAChB;IAEQoB,sBAAsBE,WAAuB,EAAE;QACrDvB,iBAAiB,IAAI,CAACQ,IAAI,EAAE;YAC1BgB,MAAM;gBACJC,QAAQ;gBACRC,gBAAgB;oBAAC;iBAAS;YAC5B;YACAH;YACAI,qBAAqB;YACrBC,aAAa;YACbC,sBAAsB3B,iBAAiB;QACzC;IACH;IAEQ4B,oBAAoB;QAC3B,MAAMC,UAAU5B,6BAA6B;YAC3C6B,+BAA+B5B;YAC/B6B,kBAAkB;QACpB;QAEA,MAAMC,4BAAuD;YAC3DN,aAAa;QACf;QAEA,MAAMO,UAAUpC;QAEhB,MAAMqC,OAAO/B,yBAAyB8B,SAASD,2BAA2B;YACxEG,YAAY;gBACVN;gBACAO,iBAAiB;oBACfC,KAAK;wBACHC,IAAI;wBACJC,MAAM;wBACNC,MAAM;wBACNC,cAAc;wBACdC,aAAa;oBACf;gBACF;YACF;YACAC,UAAU;gBAAC;oBAACN,KAAK,EAAE;gBAAA;aAAE;QACvB;QAEA,IAAI,CAAC/B,IAAI,CAACE,GAAG,CAAC,SAASJ,UAAUwC,KAAK,EAAExC,UAAUyC,KAAK,CAACX;IAC1D;IAEEY,SAAS;QACP,IAAI,CAACxC,IAAI,CAACwC,MAAM,CAAC,MAAM;YACrB/B,QAAQgC,IAAI,CAAC,CAAC,wBAAwB,CAAC;YACvChC,QAAQgC,IAAI,CAAC,CAAC,iCAAiC,CAAC;QAClD;IACF;AACF"}